using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class CodeSlidesUp3 : MonoBehaviour
{
    private Text text;
    private string str = "#include \"Tetromino.h\"\r\n#include \"myheader.h\"\r\n#include \"DisplayManager.h\"\r\n\r\nDisplayManager::DisplayManager(void) : clearedLine(0), score(0), PLAY_AREA_HEIGHT(24), PLAY_AREA_WIDTH(10), bIsHoldSlotEmpty(true), bIsRefreshNeeded(true)\r\n{\r\n\tfor (int i = 0; i < PLAY_AREA_HEIGHT; i++)\r\n\t{\r\n\t\tmemset(playArea[i], 0, sizeof(playArea[i]));\r\n\t}\r\n\r\n\tcurrentTetromino = new Tetromino(Tetromino::GetRandomTetromino());\r\n\tnextSlot = Tetromino::GetRandomTetromino();\r\n}\r\n\r\nint DisplayManager::GetClearedLine(void) const\r\n{\r\n\treturn clearedLine;\r\n}\r\n\r\nint DisplayManager::GetScore(void) const\r\n{\r\n\treturn score;\r\n}\r\n\r\nint DisplayManager::GetScreen(const int r, const int c) const\r\n{\r\n\treturn playArea[r][c];\r\n}\r\n\r\neTetromino DisplayManager::GetHoldSlot(void) const\r\n{\r\n\treturn holdSlot;\r\n}\r\n\r\neTetromino DisplayManager::GetNextSlot(void) const\r\n{\r\n\treturn nextSlot;\r\n}\r\n\r\nvoid DisplayManager::DrawCurrentTertomino(void)\r\n{\r\n\tint x = 0;\r\n\tint y = 0;\r\n\tfor (int i = currentTetromino->GetCoordinateX(); i < currentTetromino->GetCoordinateX() + 4; i++)\r\n\t{\r\n\t\tfor (int j = currentTetromino->GetCoordinateY(); j < currentTetromino->GetCoordinateY() + 4; j++)\r\n\t\t{\r\n\t\t\tif (j >= 0)\r\n\t\t\t{\r\n\t\t\t\tif (currentTetromino->GetShape(x, y) == 2 && playArea[i][j] == 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tplayArea[i][j] = 2;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ty++;\r\n\t\t}\r\n\t\ty = 0;\r\n\t\tx++;\r\n\t}\r\n}\r\n\r\nvoid DisplayManager::ClearCurrentTetromino(void)\r\n{\r\n\tint x = 0;\r\n\tint y = 0;\r\n\tfor (int i = currentTetromino->GetCoordinateX(); i < currentTetromino->GetCoordinateX() + 4; i++)\r\n\t{\r\n\t\tfor (int j = currentTetromino->GetCoordinateY(); j < currentTetromino->GetCoordinateY() + 4; j++)\r\n\t\t{\r\n\t\t\tif (j >= 0 && j < PLAY_AREA_WIDTH)\r\n\t\t\t{\r\n\t\t\t\tif (playArea[i][j] == 2)\r\n\t\t\t\t{\r\n\t\t\t\t\tplayArea[i][j] = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ty++;\r\n\t\t}\r\n\t\ty = 0;\r\n\t\tx++;\r\n\t}\r\n}\r\n\r\nvoid DisplayManager::FixCurrentTetromino(void)\r\n{\r\n\tbAlreadyCompletedSwapHold = false;\r\n\tint x = 0;\r\n\tint y = 0;\r\n\tfor (int i = currentTetromino->GetCoordinateX(); i < currentTetromino->GetCoordinateX() + 4; i++)\r\n\t{\r\n\t\tfor (int j = currentTetromino->GetCoordinateY(); j < currentTetromino->GetCoordinateY() + 4; j++)\r\n\t\t{\r\n\t\t\tif (currentTetromino->GetShape(x, y) == 2)\r\n\t\t\t{\r\n\t\t\t\tplayArea[i][j] = 1;\r\n\t\t\t}\r\n\t\t\ty++;\r\n\t\t}\r\n\t\ty = 0;\r\n\t\tx++;\r\n\t}\r\n\tClearLine();\r\n\tdelete currentTetromino;\r\n\tcurrentTetromino = new Tetromino(nextSlot);\r\n\tnextSlot = Tetromino::GetRandomTetromino();\r\n}\r\n\r\nvoid DisplayManager::Hold(void)\r\n{\r\n\tif (bAlreadyCompletedSwapHold) return;\r\n\tbAlreadyCompletedSwapHold = true;\r\n\r\n\tif (bIsHoldSlotEmpty)\r\n\t{\r\n\t\tholdSlot = currentTetromino->GetType();\r\n\t\tdelete currentTetromino;\r\n\t\tcurrentTetromino = new Tetromino(nextSlot);\r\n\t\tnextSlot = Tetromino::GetRandomTetromino();\r\n\t\tbIsHoldSlotEmpty = false;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tauto temp = holdSlot;\r\n\t\tholdSlot = currentTetromino->GetType();\r\n\t\tdelete currentTetromino;\r\n\t\tcurrentTetromino = new Tetromino(temp);\r\n\t}\r\n}\r\n\r\neCollisionDirection DisplayManager::GetSideCollisionDirection(void)\r\n{\r\n\tbool bIsCollidedLeft = false;\r\n\tbool bIsCollidedRight = false;\r\n\r\n\t//\uBCBD\uACFC \uCDA9\uB3CC \uCCB4\uD06C\r\n\tint maxY = 7;\r\n\tfor (int i = 0; i < 4; i++)\r\n\t{\r\n\t\tif (currentTetromino->GetShape(i, 3) != 0)\r\n\t\t{\r\n\t\t\tmaxY = 6;\r\n\t\t}\r\n\t}\r\n\r\n\tint minY = -3;\r\n\tint leftIdx = 3;\r\n\tfor (int i = 0; i < 4; i++)\r\n\t{\r\n\t\tfor (int j = 0; j < 3; j++)\r\n\t\t{\r\n\t\t\tif (currentTetromino->GetShape(i, j) != 0)\r\n\t\t\t{\r\n\t\t\t\tleftIdx = std::min(leftIdx, j);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tminY += 3 - leftIdx;\r\n\r\n\tif (currentTetromino->GetCoordinateY() < minY)\r\n\t{\r\n\t\tbIsCollidedLeft = true;\r\n\t}\r\n\r\n\tif (currentTetromino->GetCoordinateY() > maxY)\r\n\t{\r\n\t\tbIsCollidedRight = true;\r\n\t}\r\n\r\n\t//\uB2E4\uB978 \uD14C\uD2B8\uB85C\uBBF8\uB178\uC640 \uCDA9\uB3CC \uCCB4\uD06C\r\n\tint x = 0;\r\n\tint y = 0;\r\n\tfor (int i = currentTetromino->GetCoordinateX(); i < currentTetromino->GetCoordinateX() + 4; i++)\r\n\t{\r\n\t\tfor (int j = currentTetromino->GetCoordinateY(); j < currentTetromino->GetCoordinateY() + 4; j++)\r\n\t\t{\r\n\t\t\tif (j >= 0 && (currentTetromino->GetShape(x, y) == 2 && playArea[i][j] == 1))\r\n\t\t\t{\r\n\t\t\t\tif (y < 2)\r\n\t\t\t\t{\r\n\t\t\t\t\tbIsCollidedLeft = true;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tbIsCollidedRight = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ty++;\r\n\t\t}\r\n\t\ty = 0;\r\n\t\tx++;\r\n\t}\r\n\r\n\tif (bIsCollidedLeft && bIsCollidedRight)\r\n\t{\r\n\t\treturn eCollisionDirection::BOTH;\r\n\t}\r\n\r\n\tif (bIsCollidedLeft)\r\n\t{\r\n\t\treturn eCollisionDirection::LEFT;\r\n\t}\r\n\r\n\tif (bIsCollidedRight)\r\n\t{\r\n\t\treturn eCollisionDirection::RIGHT;\r\n\t}\r\n\r\n\treturn eCollisionDirection::NOT_COLLIDED;\r\n}\r\n\r\nbool DisplayManager::CheckCollideWithFloor(void)\r\n{\r\n\tint maxX = 21;\r\n\tfor (int i = 0; i < 4; i++)\r\n\t{\r\n\t\tif (currentTetromino->GetShape(3, i) != 0)\r\n\t\t{\r\n\t\t\tmaxX--;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tif (currentTetromino->GetCoordinateX() > maxX)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nvoid DisplayManager::ClearLine(void)\r\n{\r\n\tfor (int i = 4; i < PLAY_AREA_HEIGHT; i++)\r\n\t{\r\n\t\tbool bIsCleared = true;\r\n\t\tfor (int j = 0; j < PLAY_AREA_WIDTH; j++)\r\n\t\t{\r\n\t\t\tif (playArea[i][j] != 1)\r\n\t\t\t{\r\n\t\t\t\tbIsCleared = false;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (bIsCleared)\r\n\t\t{\r\n\t\t\tfor (int j = i; j > 0; j--)\r\n\t\t\t{\r\n\t\t\t\tfor (int k = 0; k < PLAY_AREA_WIDTH; k++)\r\n\t\t\t\t{\r\n\t\t\t\t\tplayArea[j][k] = playArea[j - 1][k];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tclearedLine++;\r\n\t\t\tscore += 100;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid DisplayManager::InputValidGameKey(eInputKey key)\r\n{\r\n\tstd::pair<int, int> curCoordinate = { currentTetromino->GetCoordinateX(), currentTetromino->GetCoordinateY() };\r\n\tint curRotateLevel = currentTetromino->GetRotateLevel();\r\n\tbIsRefreshNeeded = true;\r\n\tbool bRotateClockwise = false;\r\n\tswitch (key)\r\n\t{\r\n\tcase eInputKey::ARROW_LEFT:\r\n\t\tcurrentTetromino->SetCoordinate(currentTetromino->GetCoordinateX(), currentTetromino->GetCoordinateY() - 1);\r\n\t\tif (GetSideCollisionDirection() != eCollisionDirection::NOT_COLLIDED)\r\n\t\t{\r\n\t\t\tcurrentTetromino->SetCoordinate(currentTetromino->GetCoordinateX(), currentTetromino->GetCoordinateY() + 1);\r\n\t\t\tbIsRefreshNeeded = false;\r\n\t\t}\r\n\t\tbreak;\r\n\tcase eInputKey::ARROW_RIGHT:\r\n\t\tcurrentTetromino->SetCoordinate(currentTetromino->GetCoordinateX(), currentTetromino->GetCoordinateY() + 1);\r\n\t\tif (GetSideCollisionDirection() != eCollisionDirection::NOT_COLLIDED)\r\n\t\t{\r\n\t\t\tcurrentTetromino->SetCoordinate(currentTetromino->GetCoordinateX(), currentTetromino->GetCoordinateY() - 1);\r\n\t\t\tbIsRefreshNeeded = false;\r\n\t\t}\r\n\t\tbreak;\r\n#ifdef _DEBUG\r\n\tcase eInputKey::ARROW_UP:\r\n\t\tcurrentTetromino->SetCoordinate(currentTetromino->GetCoordinateX() - 1, currentTetromino->GetCoordinateY());\r\n\t\tif (GetSideCollisionDirection() != eCollisionDirection::NOT_COLLIDED)\r\n\t\t{\r\n\t\t\tcurrentTetromino->SetCoordinate(currentTetromino->GetCoordinateX() + 1, currentTetromino->GetCoordinateY());\r\n\t\t\tbIsRefreshNeeded = false;\r\n\t\t}\r\n\t\tbreak;\r\n#endif // _DEBUG\r\n\tcase eInputKey::ARROW_DOWN:\r\n\t\tscore++;\r\n\tcase eInputKey::TIME_PASSED:\r\n\t\tcurrentTetromino->SetCoordinate(currentTetromino->GetCoordinateX() + 1, currentTetromino->GetCoordinateY());\r\n\t\tif (CheckCollideWithFloor() == true || GetSideCollisionDirection() != eCollisionDirection::NOT_COLLIDED)\r\n\t\t{\r\n\t\t\tcurrentTetromino->SetCoordinate(currentTetromino->GetCoordinateX() - 1, currentTetromino->GetCoordinateY());\r\n\t\t\tFixCurrentTetromino();\r\n\t\t}\r\n\t\tbreak;\r\n\tcase eInputKey::Z:\r\n\t\tbRotateClockwise = true;\r\n\t\t//intentional fallthrough\r\n\tcase eInputKey::X:\r\n\t{\r\n\t\tint originalCoordinateX = currentTetromino->GetCoordinateX();\r\n\t\tint originalCoordinateY = currentTetromino->GetCoordinateY();\r\n\t\tbool bSuccess = false;\r\n\t\tif (bRotateClockwise)\r\n\t\t{\r\n\t\t\tcurrentTetromino->Rotate(eRotate::CLOCKWISE);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcurrentTetromino->Rotate(eRotate::COUNTERCLOCKWISE);\r\n\t\t}\r\n\r\n\t\t//\uD68C\uC804 \uD6C4 \uCDA9\uB3CC \uCCB4\uD06C \uBC0F \uCDA9\uB3CC \uBC29\uD5A5 \uAC80\uCD9C\r\n\t\teCollisionDirection colDir;\r\n\t\tcolDir = GetSideCollisionDirection();\r\n\t\tswitch (colDir)\r\n\t\t{\r\n\t\tcase eCollisionDirection::NOT_COLLIDED:\t//\uCDA9\uB3CC\uD558\uC9C0 \uC54A\uC558\uB2E4\uBA74 \uBB38\uC81C\uC5C6\uC774 \uD68C\uC804\uCC98\uB9AC\r\n\t\t\tbSuccess = true;\r\n\t\t\tbreak;\r\n\t\tcase eCollisionDirection::BOTH:\t//\uC591\uCABD\uC5D0\uC11C \uCDA9\uB3CC \uC2DC \uBB34\uC870\uAC74 \uC2E4\uD328\r\n\t\t\tbSuccess = false;\r\n\t\t\tbreak;\r\n\t\tcase eCollisionDirection::LEFT:\t//\uC88C\uCE21\uC5D0\uC11C \uCDA9\uB3CC \uC2DC \uC6B0\uCE21\uC73C\uB85C \uC62E\uACA8\uBCF4\uAE30\r\n\t\t\tfor (int i = 1; i <= 3; i++)\r\n\t\t\t{\r\n\t\t\t\tcurrentTetromino->SetCoordinate(currentTetromino->GetCoordinateX(), currentTetromino->GetCoordinateY() + 1);\r\n\t\t\t\tif (GetSideCollisionDirection() == eCollisionDirection::NOT_COLLIDED)\r\n\t\t\t\t{\r\n\t\t\t\t\tbSuccess = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase eCollisionDirection::RIGHT:\t//\uC6B0\uCE21\uC5D0\uC11C \uCDA9\uB3CC \uC2DC \uC88C\uCE21\uC73C\uB85C \uC62E\uACA8\uBCF4\uAE30\r\n\t\t\t//currentTetromino->SetCoordinate(originalCoordinateX, originalCoordinateY);\r\n\t\t\tfor (int i = 1; i <= 3; i++)\r\n\t\t\t{\r\n\t\t\t\tcurrentTetromino->SetCoordinate(currentTetromino->GetCoordinateX(), currentTetromino->GetCoordinateY() - 1);\r\n\t\t\t\tif (GetSideCollisionDirection() == eCollisionDirection::NOT_COLLIDED)\r\n\t\t\t\t{\r\n\t\t\t\t\tbSuccess = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tassert(false);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\t//\uC2E4\uD328\uC2DC \uD68C\uC804 \uBCF5\uAD6C\r\n\t\tif (!bSuccess)\r\n\t\t{\r\n\t\t\tcurrentTetromino->SetCoordinate(originalCoordinateX, originalCoordinateY);\r\n\t\t\tif (bRotateClockwise)\r\n\t\t\t{\r\n\t\t\t\tcurrentTetromino->Rotate(eRotate::COUNTERCLOCKWISE);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tcurrentTetromino->Rotate(eRotate::CLOCKWISE);\r\n\t\t\t}\t\t\tbIsRefreshNeeded = false;\r\n\t\t}\r\n\t\tbreak;\r\n\t}\r\n\tcase eInputKey::C:\r\n\t\tHold();\r\n\t\tbreak;\r\n\tcase eInputKey::SPACE:\r\n\t\twhile (true)\r\n\t\t{\r\n\t\t\tscore++;\r\n\t\t\tcurrentTetromino->SetCoordinate(currentTetromino->GetCoordinateX() + 1, currentTetromino->GetCoordinateY());\r\n\t\t\tif (CheckCollideWithFloor() == true || GetSideCollisionDirection() != eCollisionDirection::NOT_COLLIDED)\r\n\t\t\t{\r\n\t\t\t\tcurrentTetromino->SetCoordinate(currentTetromino->GetCoordinateX() - 1, currentTetromino->GetCoordinateY());\r\n\t\t\t\tFixCurrentTetromino();\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tbIsRefreshNeeded = false;\r\n\t\tbreak;\r\n\t}\r\n\tstd::pair<int, int> nextCoordinate = { currentTetromino->GetCoordinateX(), currentTetromino->GetCoordinateY() };\r\n\tint nextRotateLevel = currentTetromino->GetRotateLevel();\r\n\tif (curCoordinate == nextCoordinate && curRotateLevel == nextRotateLevel) bIsRefreshNeeded = false;\r\n}\r\n\r\nbool DisplayManager::CheckIsHoldSlotEmpty(void)\r\n{\r\n\treturn bIsHoldSlotEmpty;\r\n}\r\n\r\nbool DisplayManager::CheckIsRefreshNeeded(void)\r\n{\r\n\treturn bIsRefreshNeeded;\r\n}\r\n\r\nbool DisplayManager::CheckIsGameOver(void)\r\n{\r\n\tfor (int i = 0; i < 4; i++)\r\n\t{\r\n\t\tfor (int j = 0; j < PLAY_AREA_WIDTH; j++)\r\n\t\t{\r\n\t\t\tif (playArea[i][j] == 1)\r\n\t\t\t{\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}";
    private AudioSource audioSource;

    // Start is called before the first frame update
    void Start()
    {
        text = GetComponent<Text>();
        audioSource = GetComponent<AudioSource>();
        StartCoroutine(Type());
    }

    // Update is called once per frame
    void Update()
    {

    }

    IEnumerator Type()
    {
        yield return new WaitForSeconds(2f);
        for (int i = 0; i < str.Length; i++)
        {
            text.text += str[i];
            if (str[i] == '\n' || str[i] == '\r' || str[i] == '\t')
            {
                continue;
            }
            //audioSource.Play();

            yield return new WaitForSeconds(0.0002f);
        }
    }
}
